# struct (запис)
Съставен тип, който може да групира различни типове променливи на едно място.

## Синтаксис
```c++
struct <name> {
  <type_1> <var_1>;
  <type_2> <var_2>;
  ...  
};
```
```c++
// Дефинираме нов тип `Pоint`, който е съставен от `int` и `int`. 

struct Point{
    int x;
    int y;
};
```
Типът може да се дефинира глобално както горе и да се използва във всички scope-ове на програмата или да се дефинира локално и да се използва само в съответния scope. 

## Членове
В дадения по-горе пример членовете са `x` и `y`. 
- Достъпваме елементите за *конкретен* обект `Point p` чрез оператор `'.'` така: `p.x`, `p.y`.
- Ако имаме указател `Point* pPtr`, достъпваме елементите на обекта, към който указателят сочи, чрез оператор `'->'` така: `p->x`, `p->y`. _(Може и `(*p).x`, но това не е добър стил)_
   
Членовете на константни обекти не могат да бъдат променяни.

## Инициализация
```c++
// Създаваме инстанция от тип `Point`
Point p;
// За да инициализираме p, трябва да инициализираме всиките членове
p.x = 1;
p.y = -1;
```

### Стойности по подразбиране
```c++
struct DefaultPoint
{
    int x{10};
    int y{3};
};
```
```c++
Point p; // Без стойности по подразбиране
std::cout << p.x << ' ' << p.y; // Недефинирано поведение - p.x и p.y не са инициализирани

DefaultPoint pp;
std::cout << pp.x << ' ' << pp.y; // 10 3
```

### Uniform Initialization
```c++
DefaultPoint p{1, 2};
std::cout << p.x << ' ' << p.y; // 1 2

DefaultPoint partial{1}; // p.x = 1, p.y = 3
DefaultPoint empty{}; // Същото като без скобите: DefaultPoint empty; 
```

## Анонимни структури
```c++
// Обект `p` от тип анонимна структура, съставена от два `int`-a.

struct {
    int x;
    int y;
} p;
```

## Динамичнo заделени обекти и масиви
```c++
int main(){
    Point* p = new Point;
    //...
    delete p;

    Point* arr = new Point[10];
    //...
    delete[] arr;
}
```

## Функции
Структурите, както простите типове, могат да се подават на функции. Обектите могат да са много обемни, за това не искаме при всяко подаване да се копират.

### Подаваме чрез псевдоним   
```c++
void setPoint(Point& p){
    std::cin >> p.x;
    std::cin >> p.y;
}

void printPoint(const Point& p){
    // тук не можем да променяме стойностите на `x` и `y` за обекта `p`
    std::cout << '(' << p.x << ", " << p.y << ')' << std::endl;
}
```
```c++
Point p;
setPoint(p);
printPoint(p);
```
### Подаваме чрез указател   
```c++
void setPoint(Point* p){
    std::cin >> p->x;
    std::cin >> p->y;
}

void printPoint(const Point* p){
    std::cout << '(' << p->x << ", " << p->y << ')' << std::endl;
}
```
```c++
Point p;
setPoint(&p);
printPoint(&p);
```

## Динамично заделени членове
*Ако ни се наложи да имаме динамично заделен масив в обекта, трябва да се грижим за паметта!*

```c++
struct Person{
    char* firstName;
    char* lastName;
    size_t age;
};

void allocPerson(Person& p){
    p.firstName = new char[MAX_SIZE];
    p.lastName = new char[MAX_SIZE];
}

void deallocPerson(Person& p){
    delete[] p.firstName;
    delete[] p.lastName;
}
```

## Размер в паметта
Правила:
- Празните структури (без членове) са с размер 1 байт (0 означава, че не могат да имат уникален адрес)
- Всеки член започва на позиция, която се дели на неговия [alignment](https://en.cppreference.com/w/cpp/language/object#Alignment)
- Размерът се дели на най-големия размер на член

```c++
struct Test
{
    int a; // 4
    double b; // 8
    int c; // 4
};

// 4 + 8 + 4 = 16, но
std::cout << sizeof(Test); // 24

// По-малка версия на същата структура
struct TestReordered
{
    int a; // 4
    int c; // 4
    double b; // 8
};

std::cout << sizeof(TestReordered); // това вече е 16 
```

## Вложени структури
Структурите могат да съдържат в себе си данни, които също са структури. 

```c++
struct Point{
    double x;
    double y;
}

struct Circle{
    Point center; // Центъра на окръжността е точка
    double radius;
}
```
При създаването на обект от тип `Circle`, се създава и обект от тип `Point`, който се съдържа в него.   

Съответно при инициализирането обект от тип `Circle`, трябва да се инициализират и полетата на вложената структура `Point`
```c++
void initializePoint(Point& p, int x, int y){
    p.x = x;
    p.y = y;
}
void initializeCircle(Circle& c, int x, int y, int radius){
    initializePoint(c.center);
    c.radius = radius;
}
```
*Ако някоя от структурите съдържа динамична памет, трябва да се погрижим за заделянето и триенето ѝ по аналогичен начин*

## Член-функции
Както член-данни, структурите могат да имат и член-функции. Член-фунцкиите могат да:
- Позволяват промяната на обекта, т.е. на член-данните. Те не могат да бъдат викани за константни обекти.
- Да не го позволяват. След тях се пише `const` - това обозначава, че са константни методи и можем да ги използваме и върху константни обекти. В себе си могат да викат само други константни методи.

    ```c++
    struct Point{
        double x;
        double y;
    
        void initialize(double x, double y){ // може дефиницията да е в дефиницията на структурата
            this->x = x;
            this->y = y;
        }
    
        void print() const; // може и само да се декларира
    }

    void Point::print() const{ // а дефиницията да е отвън
        std::cout << x << ", " << y << std::endl;
    }
    ```
Когато член-фунцкиите са дефинирани извън структурата, можем да ги изнасяме и в различни файлове. 

- `Point.h`, в който е дефиницята на структурата        

    ```c++
    #ifndef  __POINT__HEADER__INCLUDED__
    #define __POINT__HEADER__INCLUDED__

    struct Point{
        //...
    }

    #endif 
    ```

    или за MSVC

    ```c++
    #pragma once
    struct Point{
        //...
    }
    ```

- `Point.cpp`, в който са дефинициите на член-фунцкиите. 
    ```c++
    #include "Point.h"

    void Point::print() const{
        //...
    }
    ```

## Извикване 
Както при член-данните, член-фунцкиите се извикват с операторите `.` или `->`.

```c++
int main(){
    Point p;
    p.initialize(2, 3);
    p.print();

    Point* ptr = &p;
    ptr->initialize(4, 5); //тук ще променим стойностите от 2 и 3 на 4 и 5
    ptr->print();

    const Point constant;
    constant.initialize(-1, 1); // НЕ МОЖЕ!
    constant.print(); // всичко е окей, защото print е константна член-фунцкия
}
```

## this

`this` е указател, който всяка член-фунцкия притежава. Той сочи към конкретния обект, за който е извикана функцията и чрез него могат да се достъпват данните на този обект.

```c++
Point p;
p.print(); // това извикване на print, ще има указател към p
           // еквивалентно на print(&p);
```

## Задачи
### Задача 1
Да се напише структура Student, която съдържа следната информация за един студент: първо име, възраст, факултетен номер и среден успех.

### Задача 2
Да се напишат функции за заделяне на памет за членовете (ако е нужно) и за въвеждане на стойностите им от конзолата

### Задача 3
Да се напишат функции за освобождаване на памет и извеждане на стойностите на членовете

### Задача 4
Да се напише функция, която по подадени 2 студента връща този с по-голям успех

## За упражнение
- Напишете наново структурата Student, само че вместо среден успех, тя да съдържа масив от оценките на студента. Напишете функции за създаване, изтриване, въвеждане и извеждане на оценките. Напишете функция, която по подаден студент, пресмята неговия среден успех
- Напишете функция, която по масив от студенти връща този с най-голям успех

