# Потоци
[iostream](https://cplusplus.com/reference/iostream/)

## Флагове и състояния
![състояния](https://i.stack.imgur.com/CyeS9.png)

Изчистване на състоянията: [clear](https://cplusplus.com/reference/ios/ios/clear/)

## Писане
[ostream](https://cplusplus.com/reference/ostream/ostream/) 

[operator<<](https://cplusplus.com/reference/ostream/ostream/operator%3C%3C/)       
[put](https://cplusplus.com/reference/ostream/ostream/put/) 
[tellp](https://cplusplus.com/reference/ostream/ostream/tellp/)     
[seekp](https://cplusplus.com/reference/ostream/ostream/seekp/)     
[write](https://cplusplus.com/reference/ostream/ostream/write/)     

## Четене
istream     

operator>>  
get     
seekg   
read    

## Файлови потоци   
[fstream](https://cplusplus.com/reference/fstream/fstream/)    

### Отваряне и затваряне
[Режими на отваряне](https://cplusplus.com/reference/ios/ios_base/openmode/)
```c++
std::ifstream file_in;
file_in.open("path\\to\\file", std::ios::in);
//...
file_in.close();

std::ofstream file_out;
file_out.open("path\\to\\file", std::ios::out | std::ios::trunc);
//...
file_out.close();
```

## Запазване на информация в тексов файл
- Първо трябва да създадем поток за записване във файл:
`std::ofstream outFile;`
- Посредством командата `open` с параметър пътя където да се създаде файла, отваряме файла за писане и ако не съществува го създаваме.
`outFile.open("myFile.txt");`
- Сега трябва да запишем информацията във файла. И **най-важното** да го затворим. (`outFile.close()`)

*ВАЖНО!* Не е необходимо файлът да съществува, с `open()` ще се създаде.

```cpp
int main()
{
  ofstream outFile;
  outFile.open("myfile.txt");
  char* line = new char[1000];
  cout << "Enter a line of text: ";
  getline(cin, line);
  outFile << line << endl;
  outFile.close();
  delete[] line;
  return 0;
}
```

## Четене на информация от текстов файл

- Първо създаваме `ifstream` обект, който ще използваме за работа с файла, от който ще четем.
`std::ifstream inFile;`
- Посредством командата `open` с параметър пътя където се намира файла (той трябва да съществува), отваряме файла за четене. *Обърнете внимание, че специалните символи в пътя като `\` трябва да бъдат escape-нати.*
`inFile.open("C:\\Users\\Admin\\Documents\\myFile.txt");`
- Вече можем да прочетем информацията от файла, като тук може да се въползваме от следното `while(fileName)` се изпълнява докато има данни във файла. И **най-важно** накрая да затворим файла (OS го прави за нас автоматично, но не си го пишете сами).

*ВАЖНО!* Не можем да четем от файл, който не съществува.

```cpp
#include <iostream>
#include <fstream>

int main()
{
  std::ifstream inFile;
  inFile.open("C:\\Users\\Admin\\Documents\\myFile.txt");
  char word[100];
  while (inFile) { 
    inFile.getline(word, 100);
    std::cout << word << std::endl;
  }
  inFile.close();
  return 0;
}
```

## Записване в бинарен файл (serialize)

- Първо трябва да отворим файла в бинарен режим с `std::ofstream out("C:\\Users\\Admin\\Documents\\myFile.txt", std::ios::binary);`

- Трябва да подадем указател към обекта, който записваме - ако имамем `char* str`, подаваме `str`, ако имаме `int age`, подаваме `(const char*) &age`. Когато обектът не е от тип `char*`, трябва да вземем указател към него (адреса му) и да го кастнем до `const char*`.

- При записване трябва да кажем какъв е размера на обекта, който записваме, например ако записваме `int` подаваме `sizeof(int)`, ако записваме низ - `strlen(str) + 1`.

- *ВАЖНО!* Преди да запишем масив, трябва да запишем и размера му, за да можем после да го прочетем от файла.   
```c++
int main() {
	int age = 5;
	const char* str = "Hello world!";

	std::ofstream out("Hello.dat", std::ios::binary);

	if (!out)
		std::cout << "Can't open file!\n";

  else{
	out.write((const char*)&age, sizeof(int));

	size_t size = strlen(str) + 1;
	out.write((const char*)&size, sizeof(size_t));
	out.write(str, size);

	out.close();
  }

	return 0;
}
```

## Четене от бинарен файл (deserialize)

- Както при писането отваряме в бинарен режим
- Подаваме указател към обекта, в който ще запишем данните, *но вече не е константен* - `char*`
- Подаваме размера на обекта, в който ще запишем данните - за тази стъпка беше важно при сериализиране да запазим и размера на масив!

```c++
int main() {
  int age;
  char* str = nullptr; 

	std::ifstream in(filename, std::ios::binary);

	if (!in)
		std::cout << "Can't open file!\n";

  else{
		in.read((char*)&age, sizeof(int));

		size_t size = 0;

		in.read((char*)&size, sizeof(size_t));
		str = new char[size];
		in.read(str, size);

		in.close();
  }
    
  return 0;
}
```

## Задачи 
## Task 1
Да се дефинира клас Animal, който има `име`, `порода`, `възраст` и `име на стопанин`.

Напишете фунцкиите:
- функция, която по подаден поток в бинарен режим записва информация за животно
- функция, която по подаден поток в бинарен режим чете информация за животно
- функция, която по подаден поток в текстов режим записва информация за животно
- функция, която по подаден поток в текстов режим чете информация за животно
- функция, която по подадено име на файл, го отваря бинарно и записва животно в него
- функция, която по подадено име на файл, го отваря текстово и записва животно в него

## Task 2
Да се дефинира клас Student, като всеки студент си има `име` и `възраст` *(тях няма да ги променяме или гледаме отвън)* и клас University, който също има `име`, `масив от студенти` и другите необходими за поддържането на масива елементи *(трябва да може да се разширява)* 

Напишете функциите:
- Добавяне на студент към университета   
- функция, която по подаден поток в бинарен режим записва информация за животно
- функция, която по подаден поток в бинарен режим чете информация за животно
- функции, които записват и четат университет от бинарен файл, като името на файла е  `binary_<име_на_университета>.dat` 
*Имената на файловете не се подават като аргумент, а се генерират във функциите!*
- функция, която записва всички създадени университети в текстов файл, като името на файла е
`universities.txt`. Всеки път като се отвори програмата, трябва да append-вате новите университети към файла
- функция, която чете информацията от `universities.txt` и я принтира на конзолата  

В `main` демонстрирайте създаването на обекти и извикването на тези функции върху тях.

## Task 3
Да се дефинира клас Point, като всяка точка си има координати `x`, `y` и `цвят` и клас Matrix, който представлява N x N двумерен масив от точки.

Напишете фунцкиите:
- функция, която по подаден поток в бинарен режим записва информация за животно
- функция, която по подаден поток в бинарен режим чете информация за животно
- Създаване на дъска от подаден текстов файл
- Запазване на дъската в подаден текстов файл
- Сменяне на цвета на точка с подаден нов цвят
- Сменяне на цвета на цял ред с подаден нов цвят
- Сменяне на цвета на цяла колона с подаден нов цвят
- Изчистване на дъската от цветове

Демонстрирайте в `main` как ще създадете дъска от файл, ще използвате функциите за смяна на цвят, ще я запазите и ще я изведете на конзолата.

Направете команден интерфейс, чрез който да се използват горните функции:
- `create <filename>` - създава дъската от този текстов файл
- `save <filename>` - запазва дъската в този файл
- `paint_point <x> <y> <color>` - боядисва точката с координати x и y в цвят color
- `paint_row <n>` - боядисва n-ти ред в цвят color
- `paint_col <n>` - боядисва n-та колона в цвят color
- `clear` - боядисва всички точки в някакъв неутрален цвят
- `exit` - приключва програмата


